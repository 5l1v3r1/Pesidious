# create a dqn class
class DQN(nn.Module):
	def __init__(self):
		super(DQN, self).__init__()
		self.layers = nn.Sequential(
			nn.Linear(env.observation_space.shape[0], 256),
			nn.ReLU(),
			nn.Linear(256, 64),
			nn.ReLU(),
			nn.Linear(64, env.action_space.n)
		)

	def forward(self, x):
		return self.layers(x)


	def chooseAction(self, observation, epsilon):
		rand = np.random.random()
		if rand > epsilon:
			#observation = torch.from_numpy(observation).float().unsqueeze(0).to(device)
			actions = self.forward(observation)
			action = torch.argmax(actions).item()

		else:
			action = np.random.choice(env.action_space.n)

		return action